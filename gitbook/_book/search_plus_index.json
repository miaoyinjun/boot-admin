{"./":{"url":"./","title":"项目介绍","keywords":"","body":"项目介绍 boot-admin 基于SpringBoot2、MyBatis，Vue前后端分离，自动化配置，通过封装一系列Starter，快速生成脚手架 项目、后台管理系统 项目源码 源码 后端 前端 gitee https://gitee.com/miaoyinjun/boot-admin https://gitee.com/miaoyinjun/boot-admin-ui github https://github.com/miaoyinjun/boot-admin https://github.com/miaoyinjun/boot-admin-ui 特别鸣谢 感谢eladmin 允许在基础业务功能上进行扩展 eladmin作为独立模块引入，并作了以下扩展 后端全部重写，原业务逻辑保留，Mybatis替换JPA 新的注释和代码规范 引入了新的日志模块mzt-biz-log ，并做了扩展 同时支持账号密码与短信登录，可再扩展其它方式登录 引入liquibase控制数据库结构变化，支持回滚 行列数据级别权限控制 增加注解，入参解密，出参加密，举例：返回id主键加密，保证数据安全 引入SpringBootAdmin，服务端与客户端都为当前服务，非开发模式必须登录才能使用，可查看git最后一次的提交信息，用于验证项目版本是否正确 引入knife4j替换原swagger，并增加了枚举支持，可在api文档界面下拉选择枚举 增加账号过期、密码过期、隔N天强制修改密码等机制 支持参数验证@RequestParam、@requestbody 增加版本控制菜单 使用vue-admin-beautiful-pro 重写了登录页面 定时器增加分布式锁，避免启动多个服务场景任务重复执行 crud.js支持打开编辑界面时可请求获取数据接口 其它自行体验 感谢mouzt 提供的日志组件 TODO 首页-监控，pv，uv 前端-清除缓存 后端返回菜单优化 集成springCloud k8s istio "},"directory/UNDERSTAND.html":{"url":"directory/UNDERSTAND.html","title":"快速了解","keywords":"","body":"快速了解 后端 技术 名称 说明 springBoot springBoot框架 spring Security 安全框架 权限认证 mybatis plus mybatis增强 增强对数据库操作工具 Druid 数据库连接池 提供监控 knife4j swagger接口文档增强 MapStruct Bean映射工具 jetCache 通用缓存框架 liquibase 管理数据库变化工具 跟踪,管理和应用数据库变化的数据库重构工具 p6spy SQL日志打印工具 spring-boot-admin 管理和监控SpringBoot应用程序 jasypt 配置文件加密 lombok 生成POJO的getter/setter hutool 工具类库 logback 日志框架 xxl-job 分布式定时框架 jgitflow-maven-plugin 简化实现git flow工作流程插件 git-commit-id-plugin git commit信息收集插件 maven打jar包时带上 git commit相关信息 maven-javadoc-plugin javadoc插件 检查，填充部分注释信息 screw-maven-plugin 数据库文档生成插件 springloaded 热部署插件 模块说明 boot-admin boot-admin-parent -- 父模块 boot-admin-common -- 通用定义 boot-admin-eladmin -- 基础业务 boot-admin-eladmin-generator -- 代码生成 boot-admin-eladmin-logging -- 日志 boot-admin-eladmin-system -- 系统 boot-admin-eladmin-tools -- 工具 boot-admin-starters -- 组件增强 boot-admin-cache-starter -- 缓存 boot-admin-core-starter -- 核心 boot-admin-filter-starter -- 安全过滤器 boot-admin-jackson-starter -- jackson定义 boot-admin-log-starter -- 日志 boot-admin-mybatis-starter -- mybatis定义 boot-admin-sba-starter -- spring-boot-admin增强 boot-admin-security-starter -- 安全 boot-admin-swagger-starter -- swagger增强 boot-admin-ui -- 前端 boot-admin-web-demo -- 演示 "},"directory/START.html":{"url":"directory/START.html","title":"快速开始","keywords":"","body":"快速了解 开发环境 语言：Java 8 IDE(JAVA)： IDEA 安装lombok插件 依赖管理：Maven 数据库：MySQL5.7+ 缓存：Redis 获取源码 获取后端源码 $ git clone https://gitee.com/miaoyinjun/boot-admin 获取前端源码 $ git clone https://gitee.com/miaoyinjun/boot-admin-ui 本地 1. 创建数据库 CREATE DATABASE IF NOT EXISTS `boot-admin` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 2. 环境变量配置 配置文件与参数2种，任选一种配置方式 配置文件方式（推荐） 编辑环境变量配置文件，并在底部写入以下配置，参考系统环境变量 打开配置文件 $ vim ~/.bash_profile #mysql export BOOT_ADMIN_DB_HOST=\"\" #默认localhost export BOOT_ADMIN_DB_DATABASE=\"\" #默认boot-admin export BOOT_ADMIN_DB_UNAME=\"\" #默认root export BOOT_ADMIN_DB_PASSWORD=\"\" #默认为空 export BOOT_ADMIN_DB_PORT=\"\" #默认3306 #redis export BOOT_ADMIN_REDIS_DB=\"\" #默认1 export BOOT_ADMIN_REDIS_HOST=\"\" #默认localhost export BOOT_ADMIN_REDIS_PORT=\"\" #默认redis export BOOT_ADMIN_REDIS_PASSWORD=\"16379\" #默认6379 使其生效 $ source ~/.bash_profile 参数方式 maven、jar以-D后接变量名=变量值传递环境变量 main：BOOT_ADMIN_DB_HOST=\"localhost\";BOOT_ADMIN_DB_PASSWORD=\"123\"; maven：mvn spring-boot:run -DBOOT_ADMIN_DB_HOST=localhost -DBOOT_ADMIN_DB_PASSWORD=123 jar：java -jar -DBOOT_ADMIN_DB_HOST=localhost -DBOOT_ADMIN_DB_PASSWORD=123 3. 后端运行 IDEA方式 maven方式 切换到项目根目录 $ cd boot-admin 安装必要依赖 $ cd boot-admin-parent && mvn clean install 运行demo $ cd ../ && cd boot-admin-web-demo && mvn clean compile spring-boot:run 访问接口文档：http://localhost:8801/sba/api/doc.html 4. 前端运行 切换目录 $ cd boot-admin-ui 安装依赖 $ npm i 运行 $ npm run dev 访问https://localhost:8013/ 用户名：admin，密码：123456 DOCKER 前台运行，方便查看日志 1. 后端 切换到项目根目录 $ cd boot-admin 安装必要依赖 $ cd boot-admin-parent && mvn clean install $ cd ../ && cd boot-admin-web-demo $ mvn clean install && mvn clean install && mvn dockerfile:build && docker-compose -f ./docker/docker-compose.yml --env-file=./docker/.env up 访问接口文档地址：http://localhost:8801/sba/api/doc.html 2. 前端 $ cd ../ && cd boot-admin-ui $ npm i && npm run build:docker && docker-compose -f ./docker/docker-compose.yml --env-file=./docker/.env up 访问http://localhost 用户名：admin，密码：123456 "},"directory/HTTP.html":{"url":"directory/HTTP.html","title":"接口定义","keywords":"","body":"接口HTTP定义 请求方法 GET：从服务器取出资源 POST：在服务器新建一个资源 PUT：在服务器更新资源 DELETE：从服务器删除资源 权限认证 Header参数：Authorization，内容：Berear xxx 响应 HTTP状态码 说明 200 响应正确 500 服务内部错误 400 验证错误 401 未授权 403 拒绝访问 字段说明 字段 说明 code message 消息 data 数据 code说明 code 说明 HTTP状态码 2001 success 200 5001 内部错误 500 4001 参数错误 400 4002 业务验证错误 400 4003 请求超时 400 4004 签名错误 400 4005 请不要频繁操作 400 4006 用户名或密码错误 400 4007 账户已被禁用 400 4008 账户被锁定 400 4009 账户过期 400 4010 密码过期 400 4011 未授权或授权过期 401 4012 授权过期 401 4013 找不到认证信息 401 4031 不允许访问 403 全局对返回null的处理 后端可使用注解@JacksonAllowNull允许字段返回null 类型 默认返回值 默认处理 String \"\" 无 Boolean false 无 Integer,Float,Double,BigDecimal 0 无 Long 0 无 Array,List,Set [] 无 Date null FORMAT('yyyy-MM-dd HH:mm:ss'), timeZone(GMT+8) 示例 { \"code\": 200, \"message\": \"操作成功\", \"data\": [ { \"plfName\": \"1\", \"goodId\": \"2\", \"goodUrl\": \"3\" } ] } "},"directory/GIT.html":{"url":"directory/GIT.html","title":"分支管理","keywords":"","body":"分支管理 这里简化了git flow的流程，中间可能产生的合并冲突请手动解决 版本号 主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改 次版本号：当你做了向下兼容的功能性新增 修订号：当你做了向下兼容的问题修正。 分支 master，demo和prod环境 develop，dev和qa环境 后端 Release 流程 场景：合并测试分支与生产分支 过程：合并develop分支到master分支上，并打tag 确保本地develop、master分支上没有未提交的代码，并且为最新，否则会失败 切换到develop分支 $ git checkout develop 产生release分支 $ mvn jgitflow:release-start 合并release分支到develop和master分支上，并push，tag，合并后会删除release/*分支，发布demo环境做验证 $ mvn jgitflow:release-finish Hotfix 流程 场景：在生产分支上做紧急修复 过程：从master分支建立hotfix分支，在hotfix分支上做修改，后将hotfix分支合并develop分支到master分支上，并打tag 确保本地develop、master分支上没有未提交的代码，并且为最新，否则会失败 切换到master分支 $ git checkout master 产生hotfix分支 $ mvn jgitflow:hotfix-start 在此分支上做开发push，将jenkins的demo环境分支临时修改为hotfix分支，发布demo环境做验证 $ git push --set-upstream origin hotfix/$VERSION 合并hotfix分支到develop和master分支上，并push，tag，合并后会删除hotfix/*分支，最后发布prod环境 $ mvn jgitflow:hotfix-finish 将jenkins的demo环境的分支修改为master 前端 Release 流程 场景：合并测试分支与生产分支 过程：合并develop分支到master分支上，并打tag 确保本地develop、master分支上没有未提交的代码，并且为最新，否则会失败 首次使用 $ git flow init 设置版本号 $ VERSION= 切换到develop分支 $ git checkout develop 产生release分支 $ git flow release start $VERSION 合并release分支到develop和master分支上，合并后会删除release/*分支 $ git flow release finish $VERSION push 到master分支，打tag 1. $ git push && git push --tags push develop分支，发布demo环境做验证 $ git checkout develop && git push Hotfix 流程 场景：在生产分支上做紧急修复 过程：从master分支建立hotfix分支，在hotfix分支上做修改，后将hotfix分支合并develop分支到master分支上，并打tag 确保本地develop、master分支上没有未提交的代码，并且为最新，否则会失败 设置版本号 $ VERSION= 切换到master分支 $ git checkout master 产生hotfix分支 $ git flow hotfix start $VERSION 在此分支上做开发push，将jenkins的demo环境分支临时修改为hotfix分支，发布demo环境做验证 $ git push --set-upstream origin hotfix/$VERSION 合并hotfix分支到develop和master分支上 $ git checkout hotfix/$VERSION $ git flow hotfix finish $VERSION push develop分支 $ git checkout develop && git push push 到master分支，打tag，合并后会删除hotfix/*分支，最后发布prod环境 $ git checkout master && git push && git push --tags && git push origin --delete hotfix/$VERSION 将jenkins的demo环境的分支修改为master 合并独立提交 如果需要将其它分支的commit独立合并到hotfix分支，可使用如下命令 如果要将多个提交打到hot fix 上，重复该步骤 $ git cherry-pick "},"directory/SERVER.html":{"url":"directory/SERVER.html","title":"服务器环境配置","keywords":"","body":"服务器环境配置 nginx 离线安装 上传nginx-1.18.0-2.el7.ngx.x86_64.rpm到/opt目录下 安装 cd /opt rpm -ivh nginx-1.18.0-2.el7.ngx.x86_64.rpm systemctl start nginx systemctl enable nginx setsebool -P httpd_can_network_connect 1 curl http://localhost:80 配置 上传nginx.conf到/etc/nginx目录下 上传ui.conf到/etc/nginx/conf.d目录下 上传cert 到/etc/nginx下 配置 $ cd /etc/nginx/conf.d && rm -rf default.conf && nginx -s reload redis 离线安装 上传jemalloc-3.6.0-1.el7.x86_64.rpm、rpm -ivh redis-3.2.12-2.el7.x86_64.rpm到/opt目录 安装 $ rpm -ivh jemalloc-3.6.0-1.el7.x86_64.rpm && rpm -ivh redis-3.2.12-2.el7.x86_64.rpm 启动 $ systemctl enable redis && systemctl start redis 配置 $ vim /etc/redis.conf 设置如下 requirepass \"xxxxx\" bind 0.0.0.0 port 16379 重启 $ systemctl restart redis mysql root账号连接 mysql -uroot -p 创建数据库boot-admin CREATE DATABASE IF NOT EXISTS `boot-admin` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 创建用户boot-admin，读写和只读账号 CREATE USER 'boot-admin_rw'@'%' IDENTIFIED BY '11111'; GRANT ALL ON ta.* TO 'ta_rw'@'%’; CREATE USER 'boot-admin_ro'@'%' IDENTIFIED BY '22222'; GRANT SElECT ON ta.* TO 'ta_ro'@'%'; "},"directory/BEST-PRACTICES.html":{"url":"directory/BEST-PRACTICES.html","title":"最佳实践","keywords":"","body":"最佳实践 maven私仓 已搭建好maven私有仓库 本地settings.xml文件配置好发布maven的用户 切换到boot-admin-parent目录 $ cd boot-admin-parent 发布SNAPSHOT版本，可重复发布 $ git checkout develop && $ mvn verify install:install deploy:deploy 发布RELEASE版本，不可重复发布 合并develop到master分支上，并删除pom.xml里的-SNAPSHOT标记 $ git checkout develop && mvn jgitflow:release-start && mvn jgitflow:release-finish 发布 $ git checkout master && $ mvn verify install:install deploy:deploy 完成 开发 复制boot-admin-web-demo并上传到git私库上 从git私库上克隆出boot-admin-web-demo，并切换到develop分支上 $ git clone https://gitlab.xxx.com/boot-admin-web-demo.git && git checkout develop 配置BOOT_ADMIN_MAVEN_URL环境变量 IDEA导入boot-admin-web-demo 参考liquibase的添加顺序，建表 运行Application.main，参考代码生成，生成CRUD代码 分支版本控制参考分支管理 后端部署 jenkins 配置BOOT_ADMIN_MAVEN_URL环境变量 参考服务器环境配置，确保redis，mysql环境已经准备 复制重启脚本boot-admin-web-demo/linux/restart.sh到Linux服务器相应目录下，根据需要进行修改 增加运行权限 $ chmod +x restart.sh 配置环境变量，可配置的有系统环境变量 打开配置文件 $ vim ~/.bash_profile #mysql export BOOT_ADMIN_DB_HOST=\"\" #默认localhost export BOOT_ADMIN_DB_DATABASE=\"\" #默认boot-admin export BOOT_ADMIN_DB_UNAME=\"\" #默认root export BOOT_ADMIN_DB_PASSWORD=\"\" #默认为空 export BOOT_ADMIN_DB_PORT=\"\" #默认3306 #redis export BOOT_ADMIN_REDIS_DB=\"\" #默认1 export BOOT_ADMIN_REDIS_HOST=\"\" #默认localhost export BOOT_ADMIN_REDIS_PORT=\"\" #默认redis export BOOT_ADMIN_REDIS_PASSWORD=\"16379\" #默认6379 使其生效 $ source ~/.bash_profile 使用jenkins将boot-admin-web-demo.jar复制到Linux服务器，调用restart.sh启动 $ clean package Send build artifacts over SSH Source files：target/*.jar Remove prefix：target Remote directory：/home/user1/boot-admin-web/tmp/ Exec command cd /home/user1/boot-admin-web/ mv -f boot-admin-web.jar boot-admin-web.jar.bak cp -rf ./tmp/*.jar ./ ./restart.sh 管理员登录系统，系统管理/版本管理，新建版本，激活 前端部署 准备nginx环境参考服务器环境配置 jenkins打包 $ npm install && npm run build:prod jenkins部署Send build artifacts over SSH Source files：dist/ Remove prefix：dist/ Remote directory：/etc/nginx/boot-admin-ui-tmp/ Exec command $ cd /etc/nginx/ $ rm -rf boot-admin-ui-bak $ mv -f boot-admin-ui boot-admin-ui-bak $ mv -f boot-admin-ui-tmp boot-admin-ui "},"directory/FAQ.html":{"url":"directory/FAQ.html","title":"FAQ","keywords":"","body":"常见问题 Application.main与$ mvn spring-boot:run方式运行区别 Application.main运行，dev环境推荐 与boot-admin-parent集成开发时，修改boot-admin-parent代码后，不需要install $ mvn spring-boot:run运行 与boot-admin-parent集成开发时，修改boot-admin-parent代码后，需要install @AdminRestController与@ApiRestController区别? 为了区分哪些是基础功能的url， @AdminRestController会生成/api/admin的前缀的url，基础功能接口 @ApiRestController只会生成/api/的前缀的url，新开发的接口 BaseEntity与BaseEntityLogicDelete区别？ 不需要逻辑删除表的DO类继承BaseEntity 需要逻辑删除表的DO类继承BaseEntityLogicDelete 前缀/api/admin开头的，为什么在knife4j接口文档中看不到 因/api/admin前缀下的为基础功能 所有接口与前端对接完成，很少涉及到修改 让开发者专注于新功能的开发，没有必要暴露出来 配置boot.admin.swagger.ignore-filter-path可放开/api/admin application.xml默认配置@@问题 application.yml统一获取maven的配置信息，项目信息不需要在application.xml与pom.xml分别配置2遍 spring: application: name: \"@project.name@\" #获取maven属性在应用界面与细节/信息可获取到 info: name: \"@project.name@\" description: \"@project.description@\" version: \"@project.version@\" parent引入方式 没有使用import方式，是因import会导致properties与plugins里的配置失效。 "},"frontend/vue-element-admin.html":{"url":"frontend/vue-element-admin.html","title":"前端开发","keywords":"","body":"框架说明 https://github.com/PanJiaChen/vue-element-admin/blob/master/README.zh-CN.md "},"backend/PROJECT.html":{"url":"backend/PROJECT.html","title":"代码规范","keywords":"","body":"代码规范 阿里代码规范文档 https://miaoyj.oss-cn-shanghai.aliyuncs.com/alijava.pdf 项目结构 com.boot.admin.${projectName} constant--常量 ${模块名}/api dto - 传输类（入参） vo - 输出类（出参） enums - 枚举类 ${模块名}/ domain - DO function - 日志转换 mapper - mybatis mapper\\xml mapstruct - 对象转换 rest - 控制器 service - 业务实现 代码规范检查项 POJO DO：数据库操作表类 DTO：入参 VO：出参 【强制】所有的 POJO 类属性必须使用包装数据类型 如果参数值是固定的某些值，如：删除状态、激活状态等，要定义枚举类 Controller 基础url为复数，下划线分割，如：@ApiRestController(\"students\") 单个请求的代码保持2行左右，具体实现由service处理 swagger定义检查内容 出入参是否合理，不要定义Map，Object等没有包含swagger注解说明的参数 参数验证，枚举、非空，长度等 tags关联版本号 出入参全部定义在api模块 只允许调用service处理，不允许引入mapper，DO等 定义枚举处理固定的某些值，如：动态排序，状态等 Service 外部调用的方法，出/入参不会使用DO 单表CRUD，使用BaseService内提供的方法，如this.removeById(id) 调用mapper内的自定义方法，如this.baseMapper.pageVo(page) Service/mapper 层方法命名规约 获取单个对象的方法用 get 做前缀 获取多个对象的方法用 list 做前缀，复数结尾，如:listObjects 获取统计值的方法用 count 做前缀 插入的方法用 save/insert 做前缀 删除的方法用 remove/delete 做前缀 修改的方法用 update 做前缀 page分页 liquibase 检查动作是否包含回滚语句 提交前 使用IDEA阿里代码规范插件扫描 执行：$ cd boot-admin-web-demo && mvn clean javadoc:fix javadoc:jar，自动填充代码注释@version，代码注释不规范会使控制台输出的WARNING，这时修改对应的代码注释，再重新执行命令 push/pull，如遇到冲突优先使用rebase，而不是merge "},"backend/COMMENT.html":{"url":"backend/COMMENT.html","title":"注释规范","keywords":"","body":"注释规范 开发工具：IDEA 单行注释 /** * TODO */ /** TODO */ // TODO JAVA文件-注释模板配置 菜单Preferences/Editor/Live Templates 选择顶部 By default expand with Enter 新建Template Group，名称：user 勾选 Reformat according to style 并在user下新建Live Template为cc填入以下注释模板 * * * $END$ * * * @author $user$ * @since $date$ */ Change作用范围勾选java Edit variables的Default Value列设置如下 date = date(\"yyyy-MM-dd\") user = user() 打开一个java文件，在public上方输入 /cc，按回车键，即可生成注释，填入标题 生成示例： /** * * 入口 * * * @author miaoyj * @since 2020-07-09 */ JAVA方法-注释模板 菜单Preferences/Editor/Live Templates 选择顶部 By default expand with Enter 新建Template Group，名称：user 勾选 Reformat according to style 并在user下新建Live Template为mc填入以下注释模板 * * * $END$ * * $params$$return$ */ Change作用范围勾选java Edit variables的Default Value列设置如下 params = groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i 0 && params[0] != '') {result='\\\\n'+result};if(!returnType.toString().equals('void')){return result;};\", methodReturnType(), methodParameters()); date = date(\"yyyy-MM-dd\") user = user() time = time(\"HH:mm\") 在方法上方输入 /mc + Enter，即可生成注释，填入标题、参数描述、返回描述* 生成示例： /** * * 根据商品名称查询列表 * * * @param plfName 商品名称 * @return 商品列表 */ 常量注释模板 生成示例：/** 开发 {@value} */ String DEV = \"dev\"; 子类或继承方法不需要增加注释，在其上增加： /** {@inheritDoc} */ "},"backend/HOTDEPLOY.html":{"url":"backend/HOTDEPLOY.html","title":"热加载","keywords":"","body":"热加载 $ mvn spring-boot:run，启动项目 IDEA -> 菜单Build -> Build Project 查看控制台输出，即可查看修改的class被加载了 "},"backend/CACHE.html":{"url":"backend/CACHE.html","title":"缓存操作","keywords":"","body":"缓存操作 所生成的key都会增加前缀 格式：${spring.application.name}:{keyName}，举例：boot-admin-demo:student 注解方式：JetCache，手动方式：RedisService RedisService 引入使用，具体操作方法进入RedisService自行查看 @Autowired RedisService redisService; 关系型格式规范 1: 表名,如student 2: 主键列名,如id 3: 主键值,如2,3,4...., a , b ,c 4: 第4段,写要存储的列名,如name 例：student:id:9:name String tableKey = RedisKeyUtil.getKey(\"student\", \"id\", String.valueOf(value3)); redisService.stringSetString(tableKey, value1); tableKey = RedisKeyUtil.getKeyWithColumn(\"student\", \"id\", value2, \"name\"); redisService.stringSetString(tableKey, value1); JetCache 涉及自定义的key，请定义在常量或枚举里 https://github.com/alibaba/jetcache/wiki/FAQ_CN https://github.com/alibaba/jetcache/wiki/MethodCache_CN https://github.com/alibaba/jetcache/wiki/CreateCache_CN https://github.com/alibaba/jetcache/pull/474 jetcache 与jpa的事务冲突问题 jpa Found shared references to a collection 方法1：删除事务注解 方法2：缓存执行放到最后 "},"backend/CONVERT.html":{"url":"backend/CONVERT.html","title":"类型转换","keywords":"","body":"类型转换 Java常见类型转换 https://hutool.cn/docs/#/core/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB-Convert MapStruct DO,VO映射 @Mapper(componentModel = \"spring\", unmappedTargetPolicy = ReportingPolicy.IGNORE) public interface StudentMapStruct extends BaseMapStruct { } StudentDO studentDO = this.studentMapStruct.toDO(dto); oriKaMapper备用 pojo转换 public List listStudentsByName(String uName) { QueryWrapper queryWrapper = new QueryWrapper(); if (StrUtil.isNotBlank(uName)) { Map map = MapUtil.newHashMap(); map.put(\"name\", uName); queryWrapper.allEq(map); } List list = this.list(queryWrapper); return oriKaMapper.mapAsList(list, StudentVO.class); } 自定义类型转换 定义转换器，不同类型或不同属性名的手动set ```JAVA /** 测试自定义转换 * @author miaoyj @version 1.0.9-SNAPSHOT @since 2020-07-09 / @Component public class LoginDtoToLoginVoMapper extends CustomMapper { /** {@inheritDoc} / @Override public void mapAtoB(LoginDTO loginDTO, LoginVO loginVO, MappingContext context) { loginVO.setName(loginDTO.getNickname()); super.mapAtoB(loginDTO, loginVO, context); } /** {@inheritDoc} */ @Override public void mapBtoA(LoginVO loginVO, LoginDTO loginDTO, MappingContext context) { loginDTO.setNickname(loginVO.getName()); super.mapBtoA(loginVO, loginDTO, context); } } > 2. ~~调用~~ ``` JAVA @Autowired private OriKaMapper oriKaMapper; @Override public LoginVO testOriKaMapper(LoginDTO loginDTO) { return oriKaMapper.map(loginDTO, LoginVO.class); } "},"backend/ENUM.html":{"url":"backend/ENUM.html","title":"枚举定义","keywords":"","body":"枚举定义 入参使用限制 定义在类里，只支持@RequestBody 定义在控制器里，只支持@RequestParam mybatis如何使用枚举，mybatis ENUM(枚举类)，这样定义的好处是swagger与springMVC的出入参都是value @Getter @AllArgsConstructor public enum CourseEnum { /** * 图文 */ PICTURE(\"102\", \"图文\"), /** * 音频 */ AUDIO(\"103\", \"音频\"), /** * 视频 */ VIDEO(\"104\", \"视频\"), /** * 外链 */ URL(\"105\", \"外链\"), ; @JsonValue @EnumValue private final String value; private final String desc; private static final Map MAPPINGS; static { Map temp = new HashMap<>(); for (CourseEnum courseEnum : values()) { temp.put(courseEnum.value, courseEnum); } MAPPINGS = Collections.unmodifiableMap(temp); } @JsonCreator(mode = JsonCreator.Mode.DELEGATING) public static CourseEnum resolve(String index) { return MAPPINGS.get(index); } } 字段排序枚举 @Getter @AllArgsConstructor public enum StudentSortEnum{ /** * 主键 */ ID_DESC(\"id DESC\", \"id倒序\"), ID_ASC(\"id ASC\", \"id正序\"), ; /** * Constant MAPPINGS */ private static final Map MAPPINGS; static { Map temp = new HashMap(); for (StudentSortEnum courseEnum : values()) { temp.put(courseEnum.value, courseEnum); } MAPPINGS = Collections.unmodifiableMap(temp); } @JsonValue private final String value; private final String desc; /** * * 根据index获取枚举 * * * @param index a String. * @return 枚举 * @author miaoyj * @since 2020-10-19 */ @JsonCreator(mode = JsonCreator.Mode.DELEGATING) public static StudentSortEnum resolve(String index) { return MAPPINGS.get(index); } } 使用 /** * * 测试enum * * * @param courseEnum 课程类型 * @return 登录信息 * @author miaoyj * @since 2020-07-09 */ @GetMapping(\"enum\") @ApiOperation(value = \"测试enum\") public LoginVO wd(@ApiParam(value = \"排序\", required = true) @NotNull(message = \"排序字段不正确\") @RequestParam StudentSortEnum sort, @ApiParam(value = \"课程\") @RequestParam(required = false) CourseEnum course) { LoginVO loginVO = new LoginVO(); loginVO.setCourseEnum(course); return loginVO; } 排序枚举，配合mybatisplus排序使用，mapper接口定义sort字段，orderHelper插件会在sql里自动加入order by public IPage pageVo(Integer pageIndex, Integer pageSize, String name, CourseEnum courseEnum, StudentSortEnum sort) { Page page = new Page(pageIndex, pageSize); page.addOrder(OrderItem.desc(studentOrderColumnEnum.getValue())); return this.baseMapper.pageVo(page, name, sort); } 实现效果 "},"backend/DATA-PERMISSION.html":{"url":"backend/DATA-PERMISSION.html","title":"数据权限","keywords":"","body":"数据权限 行级别 支持操作，SELECT, UPDATE, DELETE 使用注解@DataPermission，在xxMapper类上，配置后台管理系统，系统管理/角色管理/数据范围 原理是通过拦截注解@DataPermission的mapper，根据当前用户的数据范围配置，加入WHERE dept_id、created_by字段条件实现 @DataPermission.deptIdInFieldName默认使用dept_id字段 @DataPermission.userIdEQFieldName默认使用created_by字段@DataPermission public interface StudentMapper extends MyBaseMapper {} 使用datascope注意事项 多个角色重合情况下，看到自己和下级，可用同1部门解决，不会出现自己与所管人不在同一部门场景 所在机构及以下，只查父子级别 列级别 配置后台管理系统，系统管理/数据权限管理 系统管理/角色管理，菜单分配下可勾选表示禁用字段 注解@DataPermissionFieldMethod，\"student:list\"对应控制器的权限标识 返回类型只支持MyPage、Collection 分页 @DataPermissionFieldMethod(\"student:list\") public MyPage pageQuery(PageParam page, StudentSortEnum sort, StudentQueryCriteriaDTO query) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(query); return this.baseMapper.pageQuery(page, null, sort, queryWrapper); } 输出结果 { \"code\": 2001, \"message\": \"OK\", \"data\": { \"records\": [ { \"id\": 3, \"name\": \"\", \"age\": 3, \"gmtCreate\": \"2021-09-14 09:22:44\", \"createdBy\": \"System\", \"course\": 105 } ], \"total\": 3, \"pages\": 1, \"meta\": [ { \"sort\": 999, \"name\": \"姓名\", \"code\": \"name\", \"isAccessible\": false }, { \"sort\": 999, \"name\": \"年龄\", \"code\": \"age\", \"isAccessible\": true } ] } } 导出 ``` JAVA @Log(\"导出用户\") @ApiOperation(value = \"导出用户\", tags = ApiVersion.VERSION_1_0_8) @GetMapping(value = \"/download\", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE) @PreAuthorize(\"@el.check('student:list')\") public void download(@ApiParam(value = \"排序\", required = true) @NotNull(message = \"排序字段不正确\") @RequestParam StudentSortEnum sort, StudentQueryCriteriaDTO criteria) { DataPermissionFieldResult dataPermissionFieldResult = studentService.listQueryAll(sort, criteria); //downloadExcel方法自行判断哪些字段是否导出 DataPermissionFieldResult.downloadExcel(dataPermissionFieldResult); } @DataPermissionFieldMethod(\"student:list\") public DataPermissionFieldResult listQueryAll(StudentSortEnum sort, StudentQueryCriteriaDTO query) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(query); List list = this.baseMapper.queryAll(sort, queryWrapper); return DataPermissionFieldResult.build(studentMapStruct.toVO(list)); } ``` 截图 标识列对应VO定义的字段名，private String name; "},"backend/FILTER.html":{"url":"backend/FILTER.html","title":"接口/字段加密","keywords":"","body":"接口/字段加密 字段加/解密 AES入参解密、出参加密 注意事项 参与加解密的字段类型必须是String 支持的类型有：String、List、POJO、List MyPage仅支持出参类型 不会处理嵌套list 注解 @EncryptMethod，参与加/解密的方法上必须增加，参数returnVal默认false不加密出参，为true时加密出参 @EncryptField 方法的参数，对象的字段上增加 入参示例 /** * * 根据ID查询 * * * @param id ID * @return StudentVO 对象 */ @EncryptMethod public StudentVO getVoById(@EncryptField String id, @EncryptField List ids, @EncryptField StudentDTO dto, @EncryptField List dtos) { StudentDO studentDO = this.getById(id); Assert.notNull(studentDO, \"记录不存在或权限不足\"); return this.studentMapStruct.toVO(studentDO); } @Data public class StudentVO implements Serializable { @ApiModelProperty(value = \"姓名\") @EncryptField private String name; } 出参示例 @EncryptMethod(returnVal = true) public MyPage pageQuery(PageParam page, StudentSortEnum sort, StudentQueryCriteriaDTO query) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(query); return this.baseMapper.pageQuery(page, sort, queryWrapper); } 非注解处理 可使用EncryptFieldUtil类单独使用 AES加密配置属性boot.admin.filter.encryption.field.secret-key 接口加密 md5与rsa均使用的是验签的方式进行验证，不涉及数据加密 TODO 防止重复提交（批量，注解） 加密类型 MD5 请求头，必传 参数 说明 appId 应用标识 timestamp 时间戳(毫秒) nonce 随机数(10位) sign 签名 sign说明 服务端会给出一个appId和一个appKey, appKey用于参数签名使用，注意appKey保存到客户端，需要做一些安全处理，防止泄露 sign的值一般是将URL所有非空参数按照字母升序排序+appKey+timestamp+nonce拼接在一起，然后使用md5生成16进制小写字符串进行加密 公式：md5生成16进制小写字符串(ASCII升序排序URL所有参数(空参数不参与)+appKey+timestamp+nonce) RSA 使用各自语言对应的SHA256WithRSA签名函数利用商户私钥对待签名字符串进行签名，并进行Base64编码 公式：Base64.encode(RSA私钥签名(ASCII排序URL参数(空参数不参与)+timestamp+nonce)) ``` JAVA String str = \"我是一段测试aaaa\"; KeyPair keyPair = SecureUtil.generateKeyPair(AsymmetricAlgorithm.RSA.getValue(), 2048); byte[] publicKey = keyPair.getPublic().getEncoded(); byte[] privateKey = keyPair.getPrivate().getEncoded(); StaticLog.info(\"publicKey:{}\", Base64.encode((publicKey))); StaticLog.info(\"privateKey:{}\", Base64.encode(privateKey)); RSA rsa = SecureUtil.rsa(privateKey, publicKey); //公钥加密，私钥解密 byte[] encrypt = rsa.encrypt(StrUtil.bytes(str, CharsetUtil.CHARSET_UTF_8), KeyType.PublicKey); byte[] decrypt = rsa.decrypt(encrypt, KeyType.PrivateKey); // StaticLog.info(\"encrypt:{}\", Base64.encode(encrypt)); // StaticLog.info(\"decrypt:{}\", StrUtil.str(decrypt, CharsetUtil.CHARSET_UTF_8)); //私钥加密，公钥解密 // byte[] encrypt2 = rsa.encrypt(StrUtil.bytes(str, CharsetUtil.CHARSET_UTF_8), KeyType.PrivateKey); // byte[] decrypt2 = rsa.decrypt(encrypt2, KeyType.PublicKey); // StaticLog.info(\"encrypt2:{}\", Base64.encode(encrypt2)); // StaticLog.info(\"decrypt2:{}\", StrUtil.str(decrypt2, CharsetUtil.CHARSET_UTF_8)); // Signature signature = SecureUtil.generateSignature(AsymmetricAlgorithm.RSA, DigestAlgorithm.SHA256); byte[] data = str.getBytes(); Sign sign = SecureUtil.sign(SignAlgorithm.SHA256withRSA); sign.setPrivateKey(keyPair.getPrivate()); //签名 byte[] signed = sign.sign(data); //验证签名 sign = SecureUtil.sign(SignAlgorithm.SHA256withRSA); sign.setPublicKey(keyPair.getPublic()); boolean verify = sign.verify(data, signed); StaticLog.info(\"verify:{}\", verify); ``` 配置 前缀 boot.admin.filter.encryption. 参数 说明 默认值 举例 filter-urls 要过滤的地址，数组 @APIDefineField值+/** - /demo/** exclude-urls 要忽略的地址，数组 无 - /demo/students/** type 加密方式(MD5 RSA) MD5 enabled 是否启用(true false) true timestamp 超时时效，超过此时间认为签名过期毫秒 5 60 1000L 5 60 1000L nonce-length 随机数长度 10 5L applications 客户端信息(appId:appKey) 无 - id: 2 key: 22 privateKey: publicKey "},"backend/HUTOOL.html":{"url":"backend/HUTOOL.html","title":"工具类库","keywords":"","body":"工具类库 https://hutool.cn/docs/#/ "},"backend/LOG.html":{"url":"backend/LOG.html","title":"日志","keywords":"","body":"日志 默认输出路径： ./logs 输出 StaticLog提供了trace、debug、info、warn、error方法，提供变量占位符支持 StaticLog.info(\"This is static {} log.\", \"test\"); 注解-通用操作日志组件 @LogRecordAnnotation 优化自 https://github.com/mouzt/mzt-biz-log/ 此组件解决的问题是： 「谁」在「什么时间」对「什么」做了「什么事」 Change Log 优化内容 整体日志拦截在方法执行之前执行 支持对象的diff 字段增加分类、类型、模块、异常记录 使用方式 SpringBoot入口打开开关,添加 @EnableLogRecord 注解 tenant是代表租户的标识，一般一个服务或者一个业务下的多个服务都写死一个 tenant 就可以 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) @EnableLogRecord(tenant = \"com.mzt.test\") public class Main { public static void main(String[] args) { SpringApplication.run(Main.class, args); } } 日志埋点 1. 普通的记录日志 category：分类 type：类型 module：模块 value：操作内容，如：创建了一个用户, 用户姓名：「{{#dto.name}}」 pefix：是拼接在 bizNo 上作为 log 的一个标识。避免 bizNo 都为整数 ID 的时候和其他的业务中的 ID 重复。比如订单 ID、用户 ID 等 bizNo：就是业务的 ID，比如订单ID，我们查询的时候可以根据 bizNo 查询和它相关的操作日志 detail：详细内容，如：修改内容：「{STUDENT_UPDATE_DIFF_BY_DTO{#dto}}」 operatorId：可指定，如登录时，operatorId = \"{{#authUser.username}}\" SpEL 表达式：其中用双大括号包围起来的（例如：{{#order.purchaseName}}）#order.purchaseName 是 SpEL表达式。Spring中支持的它都支持的。比如调用静态方法，三目表达式。SpEL 可以使用方法中的任何参数@LogRecordAnnotation(success = \"\\{\\{#order.purchaseName\\}\\}下了一个订单,购买商品「\\{\\{#order.productName\\}\\}」,下单结果:\\{\\{#_ret\\}\\}\", prefix = LogRecordType.ORDER, bizNo = \"\\{\\{#order.orderNo\\}\\}\") public boolean createOrder(Order order) { log.info(\"【创建订单】orderNo={}\", order.getOrderNo()); // db insert order return true; } 2. 日志文案调整 参考StudentNameByIdsParseFunction，StudentUpdateDiffByDtoParseFunction 对于更新等方法，方法的参数上大部分都是订单ID、或者产品ID等， 比如下面的例子：日志记录的success内容是：\"更新了订单{{#orderId}},更新内容为....\"，这种对于运营或者产品来说难以理解，所以引入了自定义函数的功能。 使用方法是在原来的变量的两个大括号之间加一个函数名称 例如 \"{ORDER{#orderId}}\" 其中 ORDER 是一个函数名称。只有一个函数名称是不够的,需要添加这个函数的定义和实现。可以看下面例子 自定义的函数需要实现框架里面的IParseFunction的接口，需要实现两个方法： functionName() 方法就返回注解上面的函数名； apply()函数参数是 \"{ORDER{#orderId}}\"中SpEL解析的#orderId的值，这里是一个数字1223110，接下来只需要在实现的类中把 ID 转换为可读懂的字符串就可以了， 一般为了方便排查问题需要把名称和ID都展示出来，例如：\"订单名称（ID）\"的形式。 这里有个问题：加了自定义函数后，框架怎么能调用到呢？ 答：对于Spring boot应用很简单，只需要把它暴露在Spring的上下文中就可以了，可以加上Spring的 @Component 或者 @Service 很方便😄。Spring mvc 应用需要自己装配 Bean。 // 没有使用自定义函数 @LogRecordAnnotation(success = \"更新了订单\\{\\{#orderId\\}\\},更新内容为....\", prefix = LogRecordType.ORDER, bizNo = \"\\{\\{#order.orderNo\\}\\}\", detail = \"\\{\\{#order.toString()\\}\\}\") public boolean update(Long orderId, Order order) { return false; } //使用了自定义函数，主要是在 \\{\\{#orderId\\}\\} 的大括号中间加了 functionName @LogRecordAnnotation(success = \"更新了订单{ORDER{#orderId\\}\\},更新内容为...\", prefix = LogRecordType.ORDER, bizNo = \"\\{\\{#order.orderNo\\}\\}\", detail = \"\\{\\{#order.toString()\\}\\}\") public boolean update(Long orderId, Order order) { return false; } // 还需要加上函数的实现 @Component public class OrderParseFunction implements IParseFunction { @Resource @Lazy //为了避免类加载顺序的问题 最好为Lazy，没有问题也可以不加 private OrderQueryService orderQueryService; @Override public String functionName() { // 函数名称为 ORDER return \"ORDER\"; } @Override //这里的 value 可以吧 Order 的JSON对象的传递过来，然后反解析拼接一个定制的操作日志内容 public String apply(String value) { if(StringUtils.isEmpty(value)){ return value; } Order order = orderQueryService.queryOrder(Long.parseLong(value)); //把订单产品名称加上便于理解，加上 ID 便于查问题 return order.getProductName().concat(\"(\").concat(value).concat(\")\"); } } 3.日志文案调整 使用 SpEL 三目表达式 @LogRecordAnnotation(prefix = LogRecordTypeConstant.CUSTOM_ATTRIBUTE, bizNo = \"\\{\\{#businessLineId\\}\\}\", success = \"\\{\\{#disable ? '停用' : '启用'\\}\\}了自定义属性{ATTRIBUTE{#attributeId\\}\\}\") public CustomAttributeVO disableAttribute(Long businessLineId, Long attributeId, boolean disable) { return xxx; } 4. 日志文案调整 模版中使用方法参数之外的变量&函数中也可以使用Context中变量 可以在方法中通过 LogRecordContext.putVariable(variableName, Object) 的方法添加变量，第一个对象为变量名称，后面为变量的对象， 然后我们就可以使用 SpEL 使用这个变量了，例如：例子中的 {{#innerOrder.productName}} 是在方法中设置的变量，除此之外，在上面提到的自定义函数中也可以使用LogRecordContext中的变量。 （注意：LogRecordContext中变量的生命周期为这个方法，超出这个方法，方法中set到Context的变量就获取不到了） @Override @LogRecordAnnotation( success = \"\\{\\{#order.purchaseName\\}\\}下了一个订单,购买商品「\\{\\{#order.productName\\}\\}」,测试变量「\\{\\{#innerOrder.productName\\}\\}」,下单结果:\\{\\{#_ret\\}\\}\", prefix = LogRecordType.ORDER, bizNo = \"\\{\\{#order.orderNo\\}\\}\") public boolean createOrder(Order order) { log.info(\"【创建订单】orderNo={}\", order.getOrderNo()); // db insert order Order order1 = new Order(); order1.setProductName(\"内部变量测试\"); LogRecordContext.putVariable(\"innerOrder\", order1); return true; } 5. 函数中使用LogRecordContext的变量 使用 LogRecordContext.putVariable(variableName, Object) 添加的变量除了可以在注解的 SpEL 表达式上使用，还可以在自定义函数中使用 这种方式比较复杂，下面例子中示意了列表的变化，比如 从[A,B,C] 改到 [B,D] 那么日志显示：「删除了A，增加了D」 @LogRecord(success = \"{DIFF_LIST{'文档地址'\\}\\}\", bizNo = \"\\{\\{#id\\}\\}\", prefix = REQUIREMENT) public void updateRequirementDocLink(String currentMisId, Long id, List docLinks) { RequirementDO requirementDO = getRequirementDOById(id); LogRecordContext.putVariable(\"oldList\", requirementDO.getDocLinks()); LogRecordContext.putVariable(\"newList\", docLinks); requirementModule.updateById(\"docLinks\", RequirementUpdateDO.builder() .id(id) .docLinks(docLinks) .updater(currentMisId) .updateTime(new Date()) .build()); } @Component public class DiffListParseFunction implements IParseFunction { @Override public String functionName() { return \"DIFF_LIST\"; } @SuppressWarnings(\"unchecked\") @Override public String apply(String value) { if (StringUtils.isBlank(value)) { return value; } List oldList = (List) LogRecordContext.getVariable(\"oldList\"); List newList = (List) LogRecordContext.getVariable(\"newList\"); oldList = oldList == null ? Lists.newArrayList() : oldList; newList = newList == null ? Lists.newArrayList() : newList; Set deletedSets = Sets.difference(Sets.newHashSet(oldList), Sets.newHashSet(newList)); Set addSets = Sets.difference(Sets.newHashSet(newList), Sets.newHashSet(oldList)); StringBuilder stringBuilder = new StringBuilder(); if (CollectionUtils.isNotEmpty(addSets)) { stringBuilder.append(\"新增了 \").append(value).append(\"：\"); for (String item : addSets) { stringBuilder.append(item).append(\"，\"); } } if (CollectionUtils.isNotEmpty(deletedSets)) { stringBuilder.append(\"删除了 \").append(value).append(\"：\"); for (String item : deletedSets) { stringBuilder.append(item).append(\"，\"); } } return StringUtils.isBlank(stringBuilder) ? null : stringBuilder.substring(0, stringBuilder.length() - 1); } } "},"backend/JASYPT.html":{"url":"backend/JASYPT.html","title":"配置文件加密","keywords":"","body":"配置文件敏感信息加密 application.yml pwd: ENC(加密后的字段) 启动jar java -jar demo.jar --jasypt.encryptor.password=${password} 使用jasypt加解密 public static void main(String[] args) { BasicTextEncryptor textEncryptor = new BasicTextEncryptor(); //加密所需的salt(盐) textEncryptor.setPassword(\"G0CvDz7oJn6\"); //要加密的数据（数据库的用户名或密码） String username = textEncryptor.encrypt(\"root\"); String password = textEncryptor.encrypt(\"root123\"); System.out.println(\"username:\"+username); System.out.println(\"password:\"+password); } password(盐)，input(加密内容) 加密 $ java -cp ~/.m2/repository/org/jasypt/jasypt/1.9.3/jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI password=e9fbdb2d3b21 algorithm=PBEWithMD5AndDES input= 解密 $ java -cp ~/.m2/repository/org/jasypt/jasypt/1.9.3/jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringDecryptionCLI password=e9fbdb2d3b21 algorithm=PBEWithMD5AndDES input= "},"backend/LIMIT.html":{"url":"backend/LIMIT.html","title":"限流","keywords":"","body":"限流 @Limit注解 "},"backend/LIQUIBASE.html":{"url":"backend/LIQUIBASE.html","title":"数据库版本控制","keywords":"","body":"liquibase 简介 Liquibase是一个用于跟踪、管理和应用数据库变化的开源数据库重构工具。它将所有数据库的变化保存在XML文件中，便于版本控制和项目部署升级。使用该工具可以稳定、高效率地实现代码迁移与回滚。 数据库 版本： mysql5.7.8+ 默认字符集: utf8mb4 默认排序规则: utf8mb4_general_ci 创建数据库SQL CREATE DATABASE IF NOT EXISTS `boot-admin` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 建表规约 --阿里代码规范 1.【强制】表必备三字段: id,gmt_create,gmt_modified 2.【强制】逻辑删除字段: is_deleted, created_by, updated_by 3.【强制】表字段注释 4.【强制】表达是与否概念的字段 必须使用is_xxx 的方式命名，数据类型是 unsigned tinyint(1 表示是，0 表示否)。 说明:任何字段如果为非负数，必须是unsigned。 注意:POJO类中的任何布尔类型的变量，都不要加is前缀，需要在resultMap设置从is_xxx到Xxx的映射关系。 数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。 正例:表达逻辑删除的字段名is_deleted，1 表示删除，0 表示未删除。 5.【强制】索引命名。 主键索引名为pk字段名;唯一索引名为uk字段名;普通索引名则为idx_字段名。 说明:pk 即 primary key;uk 即 unique key;idx_ 即 index 的简称。 6.【强制】小数类型为decimal，禁止使用float和double。 说明:在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的 结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。 运算：https://hutool.cn/docs/#/core/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%95%B0%E5%AD%97%E5%B7%A5%E5%85%B7-NumberUtil 7.【强制】varchar 是可变长字符串不预先分配存储空间，长度不要超过5000，如果存储长度 大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 8.【推荐】表的命名最好是遵循“业务名称_表的作用”。 正例:alipay_task / force_project / trade_config 表操作 实际操作可参考resources/liquibase/1.0.0内的定义 多人开发时不推荐使用共享数据库，sql版本不好控制，推荐在开发人员本机安装数据库 推荐使用纯sql做表操作，以后迁移比较方便 一定要写回滚的语句，默认配置开启了test-rollback-on-update属性，这样做是为了保证sql更新可控，可回滚 dev、qa、demo、prod环境，update操作默认通过spring-liquibase方式执行，想手动控制sql，可修改spring.liquibase.enabled属性禁用 XML文件所在目录：resources/liquibase/changelog/[maven.project.version] 添加顺序 resources/liquibase/changelog下添加版本目录，如1.0.0 在版本目录下增加xml目录与master.xml 在xml目录增加todoxxxx.xml和sql目录 master.xml引入新添加的todoxxxx.xml 示例 resources liquibase changelog 1.0.0 xml sql 20200702_001_add_tb_student.xml -- 添加学生表 master.xml --引入20200702_001_add_tb_student.xml，并添加tag 1.1.0 xml sql 20200703_001_init_data_student.xml -- 初始化学生表数据 master.xml --引入20200703_001_init_data_student.xml，并添加tag 新增表 XML命名规范：[日期][序号]_add_tb[表名].xml 示例：20200702_001_add_tb_student.xml 初始化数据 XML命名规范：[日期][序号]_init_data[表名].xml 示例：20200703_001_init_data_student.xml 增加字段 XML命名规范：[日期][序号]_add_col[表名].xml 示例：20200703_002_add_col_student.xml 删除字段 XML命名规范：[日期][序号]_del_col[表名].xml 示例：20200703_003_del_col_student.xml 修改字段 XML命名规范：[日期][序号]_modify_col[表名].xml 示例：20200703_004_modify_col_student.xml 添加索引 uk:唯一索引, idx:普通索引 XML命名规范：[日期][序号]_add[uk/idx]_[表名].xml 示例：20200703_005_add_idx_student.xml 初始化数据CSV，不推荐 XML命名规范：[日期][序号]_init_data[表名].xml 示例：20200702_003_init_data_student.xml CSV命名规范：[日期][序号]_init_data[表名].csv 示例：20200703_001_init_data_student.csv name,age,good_id 王,1,1 大,2,3 力,3,4 数据库文档生成 screw 文档位置：target/db/doc/*.html $ mvn clean package screw:run liquibase 文档位置：target/liquibase/dbDoc/index.html $ mvn clean package liquibase:dbDoc -Dprofiles.active=${profiles.active} -Dliquibase.password=${liquibase.password} 回滚 回滚操作的前提必须有个标记位，这里使用tag 打tag方法1，推荐 需要在确认不会在改动数据库表后，在版本/master.xml里手动修改版本号 打tag方法2 $ liquibase tag ${version} > maven 打tag方法3 > 需要注意的是，CI工具要得到上次的版本号，用以获取对应的jar与liqubase的tag > 非dev环境，需要执行liquibase升级、增加标签命令： > 参数profiles.active指定了数据库配置文件与context的环境。 $ mvn clean package liquibase:updateTestingRollback liquibase:update liquibase:tag liquibase:dbDoc -Dprofiles.active=${profiles.active} -Dliquibase.password=${liquibase.password} >> 数据库变更的默认版本与pom.xml的version保持一致，无需指定版本号(mvn liquibase:tag ~~-Dliquibase.tag=1.0.0) 回滚命令： 参考 https://docsstage.liquibase.com/commands/home.html 准备工作 安装liquibase liquibase安装目录/lib/加入mysql.jar liquibase.properties位置在项目位置/resources/liquibase/master.xml的上层目录 根据实际情况任选一种 回滚-指定tag，立即执行回滚操作 $ liquibase rollback 1.0.0 --changeLogFile=liquibase/master.xml 生成回滚的sql-指定tag，不会执行回滚操作，推荐 $ liquibase rollbackSQL 1.0.1 --changeLogFile=liquibase/master.xml --outputFile=rollback_1.0.1.sql 生成回滚的sql-指定xml或sql，不实用 $ liquibase --changeLogFile=liquibase/master.xml --outputFile=future.txt futureRollbackSQL > maven方式 4.0版本已收费，废弃 $ mvn clean package liquibase:rollback -Dprofiles.active=${profiles.active} -Dliquibase.password=${liquibase.password} -Dliquibase.rollbackTag=${指定回滚到的标签版本号} 切换项目分支问题 在开发过程中切换分支可能会出现数据集不统一问题，推荐刷新或重新同步数据库，参考命令： 1.$ liquibase dropAll 2.$ liquibase update 上下文 在不同的环境中执行不同的SQL 如：在DEV环境中执行插入测试数据，在生产环境中不执行。 示例：context指定一个或多个环境下才执行，如命令不指定context参数，默认执行。 最佳实践 DEVOPS方式 更新：liquibase的update操作交给liquibase-spring，即项目启动时即自动执行update操作 回滚：在jenkins服务器上安装liquibase命令，单独建立一个job，内容：获取的项目代码分支同要发布的分支保持一致， 切换到resources/liquibase.properties目录下，使用方法1.回滚-指定tag，立即执行回滚操作 项目里liquibase.properties里不要涉及密码等信息，在执行命令时通过参数指定密码 --password 开发、DBA分离方式 更新：禁用liquibase-spring方式，使用命令生成update.sql交由DBA执行：$liquibase --changeLogFile=liquibase/master.xml updateSQL --outputFile=update.sql --contexts=prod 回滚：使用回滚方式2. 生成回滚的sql-指定tag，不会执行回滚操作，推荐，生成回滚的sql交由DBA执行 项目里liquibase.properties里不要涉及密码等信息，在执行命令时通过参数指定密码 --password Docker 待更新 问题 liquibase-maven-plugin 3.10.1版本 changeLogFile路径是src/main/resources/liquibase/master.xml 不支持 liquibase/master.xml changelog/1.0.0/master.xml addColumn remarks属性会修改表的remarks属性，需要在之后增加修改表备注SQL，独立的changeSet https://github.com/liquibase/liquibase/issues/1210 4.0.0 支持includeAll，但该标签会将会执行path下所有子目录文件（如指定场景下的SQL文件：执行完addColumn操作后的sql，会提前执行），按自排序(有潜在风险)进行执行，用includeFile指定xml与sql顺序解决。 addColumn remarks属性会修改表的remarks属性，独立的changeSet，需要在之后增加修改表备注SQL https://github.com/liquibase/liquibase/issues/1210 modifyDataType会删除字段备注 spring.liquibase.tag，不会打tag，需要用command或maven plugin，暂时使用tagDatabase解决 https://github.com/liquibase/liquibase/issues/1627 "},"backend/MYBATIS.html":{"url":"backend/MYBATIS.html","title":"mybatis","keywords":"","body":"mybatis sql输出 默认不输出，可配置环境变量：BOOT_ADMIN_DB_IS-PRINT-SQL service 单表CRUD，使用BaseService内提供的方法，如this.removeById(id) 调用mapper内的自定义方法，如this.baseMapper.pageVo(page) 分页 控制器page分页参数定义 public ResultWrapper> pageQuery(PageParam page, @ApiParam(value = \"排序\", required = true) @NotNull(message = \"排序字段不正确\") @RequestParam StudentSortEnum sort, @ApiParam(value = \"课程\") @RequestParam(required = false) CourseEnum course, @Validated StudentQueryCriteriaDTO query) { return ResultWrapper.ok(studentService.pageQuery(page, sort, course, query)); } service处理分页 public MyPage pageQuery(PageParam page, StudentSortEnum sort, CourseEnum course, StudentQueryCriteriaDTO query) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(query); if (course != null) { queryWrapper.eq(\"course\", course); } //this.page(page, queryWrapper); return this.baseMapper.pageQuery(page, sort, queryWrapper); } mapper分页 MyPage pageQuery(PageParam page, StudentSortEnum sort, @Param(Constants.WRAPPER) Wrapper wrapper); 注解@QueryCriteria查询说明 定义DTO入参 @Data public class tudentQueryCriteriaDTO{ /** * 精确 */ @ApiModelProperty(value = \"姓名\") @QueryCriteria(propName = \"name\", type = QueryCriteria.Type.EQUAL) private String name; } 引入到控制器内，不要使用注解@RequestParam public ResultWrapper> pageQuery(PageParam page, @ApiParam(value = \"排序\", required = true) @NotNull(message = \"排序字段不正确\") @RequestParam StudentSortEnum sort, @ApiParam(value = \"课程\") @RequestParam(required = false) CourseEnum course, @Validated StudentQueryCriteriaDTO query) { return ResultWrapper.ok(studentService.pageQuery(page, sort, course, query)); } 转换得到查询条件构造器queryWrapper 自定义sql方式 public MyPage pageQuery(PageParam page, StudentSortEnum sort, CourseEnum course, StudentQueryCriteriaDTO query) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(query); if (course != null) { queryWrapper.eq(\"course\", course); } return this.baseMapper.pageQuery(page, sort, queryWrapper); } mybatis plus CRUD接口方式 public List queryAll(JobQueryCriteriaDTO criteria) { QueryWrapper queryWrapper = MybatisUtil.assemblyQueryWrapper(criteria); return this.list(queryWrapper); } 逻辑删除 如果字段使用唯一索引，被逻辑删除后，如果再次插入会失败，这里的唯一索引要和逻辑删除，再加其它唯一字段（防止再次被删除）做联合索引可解决 修改人字段不会修改，解决方法 /** 根据id逻辑删除*/ StudentDO studentDO = new StudentDO(); studentDO.setId(1L); this.baseMapper.deleteByIdWithFill(studentDO); #this.removeByIdWithFill(studentDO); /**根据ids逻辑删除*/ studentDO = new StudentDO(); Wrapper wrapper = Wrappers.lambdaQuery().in(StudentDO::getId, 1, 3); this.removeBatchWithFill(studentDO, wrapper); /**根据自定义条件，逻辑批量删除*/ studentDO = new StudentDO(); Set ids = CollUtil.newHashSet(3L, 4L); this.removeBatchByIdsWithFill(studentDO, ids); 参考 https://blog.csdn.net/yuanlintufang/article/details/106180260 https://blog.csdn.net/qq_39313596/article/details/101039964 https://mybatis.plus/guide/faq.html#%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E4%B8%8B-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-%E5%8A%9F%E8%83%BD%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C 枚举支持 表示状态的字段，如锁定，正常，删除等，建议定义枚举表示，参见【枚举定义规范】 IPage pageVo(Page page, @Param(\"name\") String name, @Param(\"course\") CourseEnum courseEnum); SELECT * FROM students WHERE name LIKE concat('%',#{name},'%') WHERE course = #{course} 支持动态排序枚举 定义排序枚举 /** * * 学生 排序枚举 * * * @author miaoyj * @since 2021-02-02 * @version 1.0.0-SNAPSHOT */ @Getter @AllArgsConstructor public enum StudentSortEnum{ /** * 主键 */ ID_DESC(\"id DESC\", \"id倒序\"), ID_ASC(\"id ASC\", \"id正序\"), ; /** * Constant MAPPINGS */ private static final Map MAPPINGS; static { Map temp = new HashMap(); for (StudentSortEnum courseEnum : values()) { temp.put(courseEnum.value, courseEnum); } MAPPINGS = Collections.unmodifiableMap(temp); } @JsonValue private final String value; private final String desc; /** * * 根据index获取枚举 * * * @param index a String * @return 枚举 */ @JsonCreator(mode = JsonCreator.Mode.DELEGATING) public static StudentSortEnum resolve(String index) { return MAPPINGS.get(index); } } 枚举作为参数传入到mapper，即可自动插入排序语句List queryAll(StudentSortEnum sort, @Param(Constants.WRAPPER) Wrapper wrapper); MyBatis读取大量数据（流式读取） 导出大量数据时，虚拟机频繁GC，内存耗尽，CPU爆满，可采用Mybatis数据流式读取进行优化。 场景：java端从数据库读取100W数据进行后台业务处理。 分页读取出来。缺点：需要排序后分页读取，性能低下。 一次性读取出来。缺点：需要很大内存，一般计算机不行。 建立长连接，利用服务端游标，一条一条流式返回给java端。 jdbc中有个重要的参数fetchSize（它对业务实现无影响，即不会限制读取条数等），优化后可显著提升性能。 JDBC三种读取方式： 一次全部（默认）：一次获取全部。 流式：多次获取，一次一行。 游标：多次获取，一次多行。 Mapper层 SELECT * FROM students Dao层void exportAll(ResultHandler handler); Service层this.baseMapper.exportAll(resultContext -> { StudentVO studentVO = resultContext.getResultObject(); list.add(studentVO); }); 原理分析 先在服务端执行查询后将数据缓存在服务端。（耗时相对较长） java端获取数据时，利用服务端游标进行指针跳动，如果fetchSize为1000，则一次性跳动1000条，返回给java端缓存起来。（耗时较短，跳动次数为N/1000） 在调用next函数时，优先从缓存中取数，其次执行2过程。（内存读取，耗时可忽略） https://mybatis.plus/guide/quick-start.html#%E7%BC%96%E7%A0%81 > 拦截sql里的et问题，BaseMapper 代码生成器 > 配置文件：mybatis-plus-maven-plugin.properties > 生成命令: ~~ ~~$ mvn properties:read-project-properties boot-mybatis-plus:generate -X >将Controller里@RequestMapping的value字段修改为swagger扫描的字段，如：DemoApiConstant.API_URL + \"/students\" > 需要逻辑删除字段的，在生成entity后修改继承为BaseEntityLogicDelete "},"backend/SECURITY.html":{"url":"backend/SECURITY.html","title":"权限验证","keywords":"","body":"权限验证 注解验证 @PreAuthorize(\"@el.check('student:list')\") @GetMapping @ApiOperation(value = \"学生-列表\", tags = ApiVersion.VERSION_1_0_0) @PreAuthorize(\"@el.check('student:list')\") @LogRecordAnnotation( value = \"列表\", category = LogCategoryType.MANAGER, type = LogType.SELECT, module = ApiVersion.MODULE_STUDENT ) public ResultWrapper> pageQuery() 注解忽略 @AnonymousDeleteMapping、@AnonymousGetMapping、@AnonymousPostMapping、@AnonymousPutMapping 原理说明 前端 Permission/permission.js取到标签里的权限标识或角色与info接口里的roles做比较(store/getter.js存储permission.js里需要的内容) 后端 token.auth包含权限标识，在TokenFilter里从token取出auth设置到了Spring Security上下文中 Authentication authentication = tokenProvider.getAuthentication(token); SecurityContextHolder.getContext().setAuthentication(authentication); 用户认证 密码登录 短信登录 其它方式扩展可参考以上2种方式的代码 获取登录信息 SecurityUtils.java 配置 前缀 boot.admin.security. 建议各环境不要使用相同的jwt.secret 参数 说明 默认值 举例 exclude-urls 忽略拦截的地址，数组 无 - /demo/students/** role-urls 角色与url对应关系，数组 无 - role-name: ROLE_USER urls: - /demo/students/listPage jwt.secret token密钥 secret abc jwt.access-token-expiration token过期时间(毫秒) 7200000/2小时 7200000 jwt.refresh-token-expiration token刷新过期时间(毫秒) 7200000/2小时 7200000 jwt.token-header 授权所在的header参数名称 Authorization auth "},"backend/SWAGGER.html":{"url":"backend/SWAGGER.html","title":"接口文档","keywords":"","body":"接口文档 了解更多参考：https://doc.xiaominfo.com/ 传输类 DTO为输入与传输类，@ApiModelProperty定义名称、示例、是否必填 @Data public class LoginDTO implements Serializable { @ApiModelProperty(value = \"用户昵称\", example = \"大力\", required = true) private String nickname; @ApiModelProperty(value = \"手机号\", example = \"11111111111\", required = true) private String telephone; @ApiModelProperty(value = \"课程类型\", example = \"101\", required = true) private CourseEnum courseEnum; } VO(输出类)，@ApiModelProperty定义名称 @Data @NoArgsConstructor public class LoginVO implements Serializable { @ApiModelProperty(value = \"用户昵称\") private String name; @ApiModelProperty(value = \"手机号\", example = \"11111111111\") private String telephone; @ApiModelProperty(value = \"课程类型\", example = \"101\") private CourseEnum courseEnum; } 控制器 定义@Api定义名称,@ApiSupport定义顺序与作者 @Api(tags = \"平台商品\") @ApiSupport(order = 1, author = \"miaoyj\") @RestController @RequestMapping(value = DemoApiConstant.URL + \"/good/plf-good\", produces = MediaType.APPLICATION_JSON_VALUE) public class DemoController {} 注意@RequestParam属性required默认为true，@ApiOperation定义方法名称, @ApiParam定义参数说明，属性required默认为false @GetMapping @ApiOperation(value = \"列表\") public List list(@ApiParam(value = \"商品名称\", required = false) @RequestParam(required = false) String plfName) { return plfGoodService.listPlfGoods(plfName); } @RequestBody参数定义在DTO内，@ApiOperation定义方法名称 @PostMapping(\"testPOSTParamsValid\") @ApiOperation(value = \"POST请求，自定义验证消息\") public void testParamValid(@RequestBody LoginDTO loginBO) { StaticLog.debug(\"loginBO:{}\", loginBO); } 必须添加，@ApiOperation的tags为本次的版本号 @ApiOperation(value = \"用户分页1\", tags = DemoApiVersionConstant.VERSION_1_8_7) 分页、枚举参数 PageParam包含字段：页码、每页数量，可配合排序枚举字段使用 public ResultWrapper> pageQuery(PageParam page, @ApiParam(value = \"排序\", required = true) @NotNull(message = \"排序字段不正确\") @RequestParam StudentSortEnum sort, @ApiParam(value = \"课程\") @RequestParam(required = false) CourseEnum course, @Validated StudentQueryCriteriaDTO query) {} 过滤请求参数 https://doc.xiaominfo.com/knife4j/ignoreParameter.html 包含请求参数 https://doc.xiaominfo.com/knife4j/includeParameter.html "},"backend/VALIDATE.html":{"url":"backend/VALIDATE.html","title":"接口验证","keywords":"","body":"参数验证 控制器层 Controller 继承BaseController public class PlfGoodController extends BaseController @RequestParam参数属性required为true 参数名不传时，非空验证才生效 @GetMapping(\"testGetParamValid\") public void testParamValid(@ApiParam(value = \"用户名\", required = true) @RequestParam String name, @ApiParam(value = \"性别\", required = true) @RequestParam Integer sex) @RequestParam参数，自定义验证消息 参数存在且无值，验证自定义消息才有效 验证 枚举类型 时必须增加验证注解，才会生效，RequestParam.required = true解决了属性必须，验证注解可解决值一定是枚举里所定义的 @GetMapping(\"testGetParamCustomMsgValid\") public void testGetParamCustomMsgValid(@ApiParam(value = \"用户名\", required = true) @NotBlank(message = \"用户名不能为空\") @RequestParam(required = true) String name, @ApiParam(value = \"性别\", required = true) @NotNull(message = \"性别不能为空\") @RequestParam(required = true) Integer sex, @ApiParam(value = \"课程类型\", required = true) @NotNull(message = \"课程类型不正确\") @RequestParam(required = true) CourseEnum courseEnum ) POST/GET请求，自定义验证消息 @Validated GET请求不要加@RequestBody 所有需要验证的属性，message不能为空 @NotEmpty 用在集合上面 @NotBlank用在String上面 @NotNull用在基本数据类型上面 @PostMapping(\"testPOSTParamsValid\") public void testPOSTParamsValid(@Validated @RequestBody LoginDTO loginDTO) @GetMapping(\"testPOSTParamsValid\") public void testGetParamsValid(@Validated LoginDTO loginDTO) /** * * 登录入参 * * * @author miaoyj * @since 2020-07-09 * @version 1.0.0-SNAPSHOT */ @Data public class LoginDTO implements Serializable { @ApiModelProperty(value = \"用户昵称\", example = \"大力\", required = true) @NotBlank(message = \"用户昵称不能为空\") private String nickname; @ApiModelProperty(value = \"手机号\", example = \"11111111111\", required = true) @NotBlank(message = \"手机号不能为空\") @Length(min = 11, max = 11, message = \"手机号格式不正确\") private String telephone; @ApiModelProperty(value = \"课程类型\", example = \"101\", required = true) private CourseEnum courseEnum; } 业务层逻辑验证 例：Assert.isTrue(false, \"合同号不能为空\");[更多用法][hutool.Assert] public void testAssert() { Assert.isTrue(false, \"合同号不能为空\"); StaticLog.info(\"testAssert\"); } 分组验证 必须继承BaseDTO 使用场景：同一个DTO，新增id非必传，修改时id必传 @Data public class SampleTempDTO extends BaseDTO { @NotNull(message = \"id不能为空\", groups = Update.class) private Long id; private String cardNo; } //新增 public ResultWrapper add(@Validated @RequestBody SampleBatchDTO dto){} //修改 public ResultWrapper update(@Validated(BaseDTO.Update.class)@RequestBody SampleBatchDTO dto){} "},"backend/ENV.html":{"url":"backend/ENV.html","title":"系统环境变量","keywords":"","body":"环境变量 变量名 默认值 分类 说明 BOOT_ADMIN_WEB_PORT 8801 SERVER 服务端口 BOOT_ADMIN_WEB_PROFILES_ACTIVE dev SERVER 环境，可选（dev, qa, demo, prod） BOOT_ADMIN_DB_HOST localhost DB 数据库地址 BOOT_ADMIN_DB_DATABASE boot-admin DB 数据库名 BOOT_ADMIN_DB_UNAME root DB 数据库用户 BOOT_ADMIN_DB_PASSWORD DB 数据库密码 BOOT_ADMIN_DB_PORT 3306 DB 数据库端口 BOOT_ADMIN_DB_IS-PRINT-SQL false DB 是否打印sql BOOT_ADMIN_REDIS_DB 1 REDIS redis数据库名 BOOT_ADMIN_REDIS_HOST localhost REDIS redis地址 BOOT_ADMIN_REDIS_PORT redis REDIS redis端口 BOOT_ADMIN_REDIS_PASSWORD 6379 REDIS redis密码 BOOT_ADMIN_LOG_PATH ./logs 日志 日志路径 BOOT_ADMIN_FILTER_ENCRYPTION_FIELD_SECRET-KEY YgnE7hAjiifYFibD 过滤器 字段加密，密钥 BOOT_ADMIN_SBA_PASSWORD 3nxnn4mtLyzn SBA spring-boot-admin密码 BOOT_ADMIN_SBA_SERVER_URL http://localhost:${server.port} SBA spring-boot-admin注册的服务端地址 BOOT_ADMIN_USER_PASSWORD_DEFAULT-VAL 123456 USER 新用户默认密码 BOOT_ADMIN_SECURITY_JWT_BASE64-SECRET * USER jwt_security BOOT_ADMIN_MAVEN_URL MAVEN maven仓库地址如：http://x.x.x.x:1111/repository "},"backend/SBA.html":{"url":"backend/SBA.html","title":"服务监控","keywords":"","body":"spring-boot-admin 当前服务即是客户端也是服务端，监控服务运行状态 如需独立spring-boot-admin服务端监控多个服务，可启动boot-admin-sba-server，修改环境变量BOOT_ADMIN_SBA_SERVER_URL为spring-boot-admin服务端的地址即可 访问http://localhost:8801/sba/， 进入实例 dev环境无密码，其它环境必须提供密码，配置路径参见【环境变量】 项目信息，GIT最近一次的提交记录 knife4j接口文档入口 druid数据库监控入口 日志（DEV环境不会产生日志文件，所以不能查看，可切换到其它环境验证日志） 再也不用到服务器上查看日志了 其它如环境变量，配置文件等监控可自行摸索 "},"backend/CODE-GENERATOR.html":{"url":"backend/CODE-GENERATOR.html","title":"代码生成","keywords":"","body":"代码生成 这里拿student表做生成示例 在数据库管理工具中将student表复制并重命名为teacher 点击配置 配置接口信息 配置字段，生成 代码生成完成 前端代码配置 移动teacher/api.js到boot-admin-ui/src/api下，移动teacher/index.vue到boot-admin-ui/src/views/system/下 手动执行sql/TeacherMenuRoleSql.sql（回滚sql已注释），添加菜单、权限赋予超级管理员角色（一般这段sql会由liquibase自动执行） 重启后端boot-admin-web-demo，刷新缓存方法，任选一种 用户退出再登录前端页面 管理员到菜单->角色管理->超级管理员->菜单分配->保存 最终效果 "},"backend/XXL-JOB-CLIENT.html":{"url":"backend/XXL-JOB-CLIENT.html","title":"xxl-job-client","keywords":"","body":"XXL-JOB 客户端 配置 前缀 boot.admin.xxl.job. 参数 说明 默认值 admin.addresses 服务地址 http://localhost:8888/xxl-job-admin accessToken 服务令牌 无 executor.appname 客户端名称 ${spring.application.name} executor.address 客户端地址 无 executor.ip 客户端IP 无 executor.port 客户端端口 9999 executor.logretentiondays 客户端日志保存时长 30 executor.logpath 客户端日志地址 ${log.path:./logs/} "}}